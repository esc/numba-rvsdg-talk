== Introduction ==

==== Outline ====

\tableofcontents[currentsection]

==== @whoami@ ====

* Val Haenel ("val" like @let val =@)
* \href{https://github.com/esc}{https://github.com/esc}
* Compiler Engineer at Anaconda
* Working on \href{https://numba.pydata.org/}{Numba} full-time
* Doing this for over 5 years

==== Introduction ====

* Using a Structured Control Flow Graph (SCFG)
* Regularize Python, identify branches and loops
* Implemented in package \href{https://github.com/numba/numba-rvsdg}{numba-rvsdg}

==== Motivation ====

* Make code more ammeanable for Python compilers
* First step towards an source frontend for Numba
* (Numba currently uses bytecode...)

==== Definitions ====

* AST ==>  Abstract Syntax Tree
* IR ==> Intermediary Representation
* CFG ==> Control Flow Graph
* DAG ==> Directed Acyclic Graph
* Closed CFG ==> CFG with eaxctly one entry and one exit node
** Entry node ==> No incoming edges
** Exit node ==> No outgoing edges
* SCFG ==>  Structured Control Flow Graph
* RVSDG ==> Regionalized Value State Dependence Graph

==  Pipeline ==

==== Outline ====

\tableofcontents[currentsection]

==== Pipeline ====

* Ingest Python source
* Convert to AST
* Convert AST to CFG
* Restructure to SCFG
* Synthesize Python source code [implemented]
* Convert to RVSDG [partially implemented]
* Profit! [this is what copilot suggested]

==== SCFG Restructuring ====

* CFG --> SCFG
* Algorithm based on \href{https://dl.acm.org/doi/pdf/10.1145/2693261}{Bahmann2015}
* Pre-processing for conversion to RVSDG
* Useful in it's own right

==== SCFG Restructuring ====

* Three stages:
** @CLOSE CFG@
** @LOOP RESTRUCTURE@
** @BRANCH RESTRUCTURE@

==== SCFG Restructuring ====

* Identifies loop and branch regions
* Loops become closed and tail controlled (do-while) with a single backedge
* Branch regions are identified as a structure of
** one head region
** two or more branch regions
** one tail region

--.5cm--

* Since backedges are contained within loop regions..
* --> we can conceal the loop regions
* --> to obtain a Directed Acyclic Graph (DAG)

==== Plans ====

* Use as source pre-processor for Numba
* Use as IR for a source frontend for Numba
* Other use-cases...?

==== Example ====[containsverbatim]

\begin{ipythonconsolecode}
In [1]: from numba_rvsdg import AST2SCFG

In [2]: def function():
   ...:     return 1
   ...:

In [3]: scfg = AST2SCFG(function)

In [4]: scfg.view()
\end{ipythonconsolecode}

==== CFG ====

<[center]
    <<<assets/images/function-cfg.pdf, height=0.85\textheight>>>
[center]>

== Examples ==

==== Outline ====

\tableofcontents[currentsection]

=== Branch ===

==== Outline ====

\tableofcontents[currentsubsection]

==== Branch ====[containsverbatim]

* A simple example

--.5cm--

<[center]
    \pyfile{assets/source/branch.py}
[center]>

==== CFG ====

* CFG is already closed

<[center]
    <<<assets/images/branch-cfg.pdf, height=0.85\textheight>>>
[center]>

==== SCFG ====

* Only branch regions are identified

<[center]
    <<<assets/images/branch-scfg.pdf, height=0.85\textheight>>>
[center]>

=== Multi Return ===

==== Outline ====

\tableofcontents[currentsubsection]

==== Multi Return ====[containsverbatim]

* This example has two @return@ statements

--.5cm--

\pyfile{assets/source/multi_return.py}

==== CFG ====

* The CFG is not closed, two exit nodes

<[center]
    <<<assets/images/multi_return-cfg.pdf, height=0.85\textheight>>>
[center]>

==== SCFG ====

* The @CLOSE CFG@ algorithm will insert an exit node

<[center]
    <<<assets/images/multi_return-scfg.pdf, height=0.85\textheight>>>
[center]>

==== Transformed ====[containsverbatim]

* Finally, we can synthesize Python
* The transformed function only has a single exit node
* It is now closed

--.5cm--

\pyfile{assets/transformed/multi_return.py}

=== While Loop ===

==== Outline ====

\tableofcontents[currentsubsection]

==== While Loop ====[containsverbatim]

* Next up: a simple loop

--.5cm--

\pyfile{assets/source/while_loop.py}

==== CFG ====

<[center]
    <<<assets/images/while_loop-cfg.pdf, height=0.85\textheight>>>
[center]>

==== SCFG ====

<[center]
    <<<assets/images/while_loop-scfg.pdf, height=0.85\textheight>>>
[center]>

==== Transformed ====[containsverbatim]

* The transformed variant is as close to a do-while loop as we can get in Python

--.5cm--

\pyfile{assets/transformed/while_loop.py}

=== Early Exit ===

==== Outline ====

\tableofcontents[currentsubsection]

==== Early Exit ====[containsverbatim]

* Let's combine all three stages in this example
* The loop has an "early exit"

--.5cm--

\pyfile{assets/source/early_exit.py}

==== CFG ====

<[center]
    <<<assets/images/early_exit-cfg.pdf, height=0.85\textheight>>>
[center]>

==== SCFG ====

<[center]
    <<<assets/images/early_exit-scfg.pdf, height=0.85\textheight>>>
[center]>

==== Transformed ====[containsverbatim]

\pythonfile{assets/transformed/early_exit.py}

=== For Loop ===

==== Outline ====

\tableofcontents[currentsubsection]

==== For Loop ====[containsverbatim]

* Python for-loops need to be "de-sugared"
** --> such that they can be represented using the "blocks and edges" semantics of the CFG formalism

--.2cm--

* Setup the induction variable
* Setup the iterator
* Use @next@ to determine when to stop instead of catching the @StopIteration@ exception
* The induction variable must escape the scope

--.2cm--

\pyfile{assets/source/for_loop.py}

==== CFG ====

* De-sugaring happens on-the-fly during conversion to CFG

<[center]
    <<<assets/images/for_loop-cfg.pdf, height=0.85\textheight>>>
[center]>

==== SCFG ====

<[center]
    <<<assets/images/for_loop-scfg.pdf, height=0.85\textheight >>>
[center]>

==== Transformed ====[containsverbatim]

* for-loop becomes while-loop

\pyfile{assets/transformed/for_loop.py}


=== Break and Continue ===

==== Outline ====

\tableofcontents[currentsubsection]

==== Break and Continue ====[containsverbatim]

\pyfile{assets/source/break_and_continue.py}

==== CFG ====

<[center]
    <<<assets/images/break_and_continue-cfg.pdf, height=0.85\textheight>>>
[center]>

==== SCFG ====

<[center]
    <<<assets/images/break_and_continue-scfg.pdf, height=0.85\textheight >>>
[center]>

==== Transformed ====[containsverbatim]

\inputminted[lastline=21, fontsize=\scriptsize]{python}{assets/transformed/break_and_continue.py}

==== Transformed ====[containsverbatim]

\inputminted[firstline=22, fontsize=\scriptsize]{python}{assets/transformed/break_and_continue.py}











==== slide 2 ====

* bullet 1
* bullet 2
* bullet 3

=== Subsection 2 ===

==== Outline ====

\tableofcontents[currentsection,currentsubsection]

==== Block ====

<[block]{Block Title}
Block contents
[block]>

==== Special Symbols ====

* Tilde: \~{}
* Tilde: \textasciitilde{}
* Caret: \^{}
* Hash: \#
* Braces: \{\}
* Dollar: \$
* Double en: -{}-
* At in Typewriter: {\tt stash@\{0\} }
* Exclamation mark in alert: \alert{Attention!}

or use: nowiki

==== Correct Escapes  ====

This only works with my patched version of wiki2beamer.

* @HEAD \@ HEAD@
* Attention\! Attention\!

==== Verbatim ====[fragile]

\begin{verbatim}

wiki2beamer slides.wiki > slides.wiki.tex
pdflatex slides.tex

\end{verbatim}

[frame]>

==== Verbatim2 ====[containsverbatim]

<[verbatim]

wiki2beamer slides.wiki > slides.wiki.tex
pdflatex slides.tex

[verbatim]>

==== Verbatim Block ====[containsverbatim]

<[block]{Verbatim Block}
<[verbatim]

wiki2beamer slides.wiki > slides.wiki.tex
pdflatex slides.tex

[verbatim]>
[block]>

==== Code ====[containsverbatim]

\begin{pycode}
def python_func(arg):
    print 'arg was: ', arg

python_func('Hello World!")
\end{pycode}

==== Code from file ====

\pyfile{code/code.py}

==== Example ====

<[example]
    This is an example
[example]>

==== Conclusion ====

* Open source tools used to make this presentation:
** \href{http://wiki2beamer.sourceforge.net/}{Wiki2beamer}
** \href{http://latex-beamer.sourceforge.net/}{\LaTeX beamer}
** \href{http://projects.gnome.org/dia/}{Dia}
** \href{http://pygments.org/}{Pygments}
** \href{http://code.google.com/p/minted/}{Minted}
** \href{https://bitbucket.org/john2x/solarized-pygment}{Solarized theme for pygments}
